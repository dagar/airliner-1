extends ../common/layout

block header
  i.fa-fw.fa.fa-signal
  | Pilot Display (Test)

block main
  .row
    article.col-xs-12.col-sm-10.col-md-10.col-lg-10
      #wid-Flight-HUD.jarviswidget.jarviswidget-color-blueDark(data-widget-editbutton='false',data-widget-colorbutton='false',data-widget-deletebutton='false')
        header
          span.widget-icon
            i.fa.fa-table
          h2 Attitude Indicator
        div
          .jarviswidget-editbox
            input.form-control(type='text')
          .widget-body(style='padding: 0px')
            #touchpad
              #hud(style='padding: 0px; margin-bottom: -5px;')
  .toggle_switch
    br
    table(style="width:250px")
      tbody
        tr
          td(style='width: 70px;')
            h2 Video
          td
            table
              tbody
                tr
                  td
                    table(style='width: 70px;')
                      tbody
                        tr
                          td(style='width: 15px;') OFF
                          td(style='width: 40px;')
                          td(style='width: 15px;') ON
                tr
                  td
                    label.switch
                      input(type="checkbox")
                      span(class="v_slider round")
  script.
    var vid = new Video();
    $('input:checkbox').change(
    function(){

        if ($(this).is(':checked')) {
          var Position = {Lat: 0, Lon: 0, Alt: 0};
          var Attitude = {Yaw: 0, Pitch: 0, Roll: 0};
          var HUDCount = 0;
          var HUDStarted = false;

          //flyToLocation();

          /* Heads Up Display */

          var draw;
          var curHeading = 0;
          var curPitch = 0;
          var curRoll = 0;
          var curAltitude = 0.0;
          var textHeading;
          var hdTicks;
          var hdTicksMask;
          var hdWidth;
          var hudHeight;
          var hudWidth;
          var pxPer15Degrees;
          var pxPerDegree;
          var degPerPitchLine = 15;
          var posPitchLineOnScreen = 3.5;
          var pxPerPitchLine;
          var pxPerDegreePitch;
          var pitchIndicator;
          var altPosMetersOnScreen = 5;
          var altPxPerMeter;
          var altitudeIndicator;
          var textAltitude;
          var altTicks;
          var OffsetY = 0;
          var rotation = 0;
          var hrzWidth;
          var cameraImage;
          var imageBuffer;

          var Q = [];
          //var tlm_o = new Telemetry();

          sm.subscribeTelemetry({'tlm': [
             {'name': '/CFS/PX4/VGPP_Alt'}
             ]},
             function (param) {
                Position.Alt = (param.engValue.sint32Value - 488269) / 1000.0;
             }
          );

          sm.subscribeTelemetry({'homogeneity': {tolerance: 0.5}, 'tlm': [
             {'name': '/CFS/PX4/VA_Q_0'},
             {'name': '/CFS/PX4/VA_Q_1'},
             {'name': '/CFS/PX4/VA_Q_2'},
             {'name': '/CFS/PX4/VA_Q_3'}
             ]},
             function (param) {
                switch(param.id.name){
                    case '/CFS/PX4/VA_Q_0':
                        Q[0] = param;
                        break;
                    case '/CFS/PX4/VA_Q_1':
                        Q[1] = param;
                        break;
                    case '/CFS/PX4/VA_Q_2':
                        Q[2] = param;
                        break;
                    case '/CFS/PX4/VA_Q_3':
                        Q[3] = param;
                        break;
                }

                try{
                    if((Q[0].generationTimeUTC == Q[1].generationTimeUTC) &&
                       (Q[1].generationTimeUTC == Q[2].generationTimeUTC) &&
                       (Q[2].generationTimeUTC == Q[3].generationTimeUTC))
                    {
                        var q0 = Q[0].engValue.floatValue;
                        var q1 = Q[1].engValue.floatValue;
                        var q2 = Q[2].engValue.floatValue;
                        var q3 = Q[3].engValue.floatValue;

                        var phi = Math.atan2((q2*q3)+(q0*q1), 0.5 - (q1*q1)-(q2*q2));
                        var theta = Math.asin(-2*((q1*q3)-(q0*q2)));
                        var psi = Math.atan2((q1*q2)-(q0*q3),0.5-((q2*q2)+(q3*q3)));

                        Attitude.Pitch = theta;
                        Attitude.Roll = -phi;
                        Attitude.Yaw = -57.2958*psi;
                        if(Attitude.Yaw < 0){
                            Attitude.Yaw += 360.0;
                        }

                        HUDStarted = true;
                    }
                } catch (e) {
                }
            }
          );

          setInterval(function () {
            if (HUDStarted == true) {
              updateHUDAltitude(Position.Alt);
              updateHUDHeading(Attitude.Yaw);
              updateHUDPitch(Attitude.Pitch * 57.2958);
              updateHUDRoll(Attitude.Roll * 57.2958);
            }
          }, 33);

          drawHUD();

          function updateHUDHeading(newHeading) {
            textHeading.text(newHeading.toFixed(0).toString());
            hdTicks.x(-newHeading * pxPerDegree);
          }

          function updateHUDPitch(newPitch) {
            OffsetY = newPitch * pxPerDegreePitch;
            //pitchIndicator.rotate(0);
            //pitchIndicator.y(0);
            //pitchIndicator.animate(10, '-', 0).y(OffsetY).rotate(rotation);
          }

          function updateHUDRoll(newRoll) {
            rotation = newRoll;
            pitchIndicator.rotate(0);
            pitchIndicator.y(0);
            pitchIndicator.y(OffsetY).rotate(rotation);
          }

          function updateHUDAltitude(newAltitude) {
            textAltitude.text(newAltitude.toFixed(1).toString());
            altTicks.y(newAltitude * altPxPerMeter);
          }

          $('#hud').on('resize', function (event) {
            console.log("Resized");
            $('svg').remove();
            drawHUD();
            //updateHUDAltitude(10);
            //updateHUDHeading(20);
            //updateHUDPitch(30);
            //updateHUDRoll(40);
          });



          var toggle = 0;
          console.log('video stream being called');
          vid.getVideoStream(function(image) {
            imageBuffer = image.data;
            cameraImage.load('data:image/jpeg;base64,' + imageBuffer);
          });

          function drawHUD() {
            var aspectRatio = 320.0 / 180.0;
            hudWidth = $('#hud').width();
            hudHeight = hudWidth / aspectRatio;
            if ($(window).height() < hudHeight) {
              hudHeight = $(window).height() - 50;
              hudWidth = hudHeight * aspectRatio;
            }
            draw = SVG('hud').size('100%', hudHeight);

            if (SVG.supported == false) {
              alert('SVG not supported with ths browser.');
            }
            else {
              var bgOpacity = 0.5;
              var rect = draw.rect('100%', '100%').attr({fill: '#000000'});
              //draw.fixSubPixelOffset();
              draw.attr('preserveAspectRatio', 'x320Y180 meet');

              /* -------------------------
               Draw the camera video
               ------------------------- */
              //var defs = draw.defs();
              //var cameraVideoClip = defs.clip().rect(hudWidth, hudHeight).move(0, 0);
              cameraImage = draw.image('data:image/jpeg;base64,' + imageBuffer, hudWidth, hudHeight);

              var rollIndicator = draw.group();

              /* -------------------------
               Draw altimeter
               ------------------------- */
              var altWidth = 50;
              var altHeight = hudHeight - 10;
              var altWidth = 50;
              var altHeight = hudHeight - 10;
              altPxPerMeter = altHeight / altPosMetersOnScreen;
              var altPxPerDecimeter = altPxPerMeter / 10.0;
              var altPxPerCentimeter = altPxPerMeter / 100.0;
              var altPxPerMillimeter = altPxPerMeter / 1000.0;

              var altimeter = draw.group();
              var altBorder = altimeter.group();
              /* Draw border. */
              var altRec1 = altBorder.rect(altWidth, altHeight).attr({
                x: hudWidth - altWidth - 5,
                y: 5,
                stroke: '#000000',
                'stroke-width': '3px',
                rx: 5,
                ry: 5,
                'fill-opacity': bgOpacity
              });
              var altRec2 = altBorder.rect(altWidth, altHeight).attr({
                x: hudWidth - altWidth - 5,
                y: 5,
                stroke: '#00ff00',
                rx: 5,
                ry: 5,
                'fill-opacity': bgOpacity
              });
              /* Draw ticks group. */
              var altTicksArea = altimeter.group();
              altTicks = altTicksArea.group();
              for (i = 0; i < (10 * (altPosMetersOnScreen + 1 + 30)); i++) {
                y = (hudHeight / 2) - i * (altPxPerDecimeter);
                /* Draw a longer line if its a meter interval. */
                if (i % 10 == 0) {
                  altTicks.line(hudWidth - altWidth - 3, y, hudWidth - altWidth + 20, y).attr({
                    width: 2,
                    stroke: '#00ff00'
                  });

                  var textAltTick = altTicks.text((i / 10.0).toString()).move(hudWidth - altWidth + 30, y - 5);
                  textAltTick.font({
                    fill: '#00ff00',
                    anchor: 'start',
                    size: 13
                  });
                }
                else {
                  /* This is just a decimeter tick. */
                  altTicks.line(hudWidth - altWidth - 3, y, hudWidth - altWidth + 10, y).attr({
                    width: 1,
                    stroke: '#00ff00'
                  });
                }
              }
              for (i = 0; i > (-10 * (altPosMetersOnScreen + 1)); i--) {
                y = (hudHeight / 2) - i * (altPxPerDecimeter);
                /* Draw a longer line if its a meter interval. */
                if (i % 10 == 0) {
                  altTicks.line(hudWidth - altWidth - 3, y, hudWidth - altWidth + 20, y).attr({
                    width: 2,
                    stroke: '#00ff00'
                  });

                  var textAltTick = altTicks.text((i / 10.0).toString()).move(hudWidth - altWidth + 30, y - 5);
                  textAltTick.font({
                    fill: '#00ff00',
                    anchor: 'start',
                    size: 13
                  });
                }
                else {
                  /* This is just a decimeter tick. */
                  altTicks.line(hudWidth - altWidth - 3, y, hudWidth - altWidth + 10, y).attr({
                    width: 1,
                    stroke: '#00ff00'
                  });
                }
              }
              /* Draw center altitude indicator. */
              var altCenter = altimeter.group();
              var altCenterHeight = 30;
              altCenter.polyline([
                [hudWidth - altWidth - 5, hudHeight / 2],
                [hudWidth - altWidth + 15, (hudHeight - altCenterHeight) / 2],
                [hudWidth - 5, (hudHeight - altCenterHeight) / 2],
                [hudWidth - 5, (hudHeight + altCenterHeight) / 2],
                [hudWidth - altWidth + 15, (hudHeight + altCenterHeight) / 2],
                [hudWidth - altWidth - 5, hudHeight / 2]]).attr({
                stroke: '#000000',
                'stroke-width': 3,
                'fill-opacity': 0.0
              });
              altCenter.polyline([
                [hudWidth - altWidth - 5, hudHeight / 2],
                [hudWidth - altWidth + 15, (hudHeight - altCenterHeight) / 2],
                [hudWidth - 5, (hudHeight - altCenterHeight) / 2],
                [hudWidth - 5, (hudHeight + altCenterHeight) / 2],
                [hudWidth - altWidth + 15, (hudHeight + altCenterHeight) / 2],
                [hudWidth - altWidth - 5, hudHeight / 2]]).attr({
                stroke: '#00ff00',
                'stroke-width': 2,
                'fill-opacity': 0.0
              });
              textAltitude = altCenter.text('0.0').move(hudWidth - altWidth + 14, (hudHeight / 2) - 9);
              //textAltitude.attr("dominant-baseline", "middle");
              textAltitude.font({
                fill: '#00ff00',
                size: 18
              });
              var altTicksMask = altimeter.mask();
              altTicksMask.rect(hudWidth, hudHeight).attr({
                fill: '#000000'
              });
              altTicksMask.rect(altWidth, altHeight).attr({
                x: hudWidth - altWidth - 5,
                y: 5,
                fill: '#ffffff',
                'stroke-width': '3px',
                rx: 5,
                ry: 5
              });
              altTicksMask.polyline([
                [hudWidth - altWidth - 5, hudHeight / 2],
                [hudWidth - altWidth + 15, (hudHeight - altCenterHeight) / 2],
                [hudWidth - 5, (hudHeight - altCenterHeight) / 2],
                [hudWidth - 5, (hudHeight + altCenterHeight) / 2],
                [hudWidth - altWidth + 15, (hudHeight + altCenterHeight) / 2],
                [hudWidth - altWidth - 5, hudHeight / 2]]).attr({
                fill: '#000000'
              });
              altTicksArea.maskWith(altTicksMask);

              /* -------------------------
               Draw Heading
               ------------------------- */
              var hdHeight = 50;
              hdWidth = hudWidth - 120;
              pxPer15Degrees = (hdWidth / 2) / 5;
              pxPerDegree = pxPer15Degrees / 15.0;
              var heading = draw.group();
              var headingBorder = heading.group();
              /* Draw border. */
              var hdRec1 = headingBorder.rect(hdWidth, hdHeight).attr({
                x: (hudWidth - hdWidth) / 2,
                y: hudHeight - hdHeight - 5,
                stroke: '#000000',
                'stroke-width': '3px',
                rx: 5,
                ry: 5,
                'fill-opacity': bgOpacity
              });
              var hdRec2 = headingBorder.rect(hdWidth, hdHeight).attr({
                x: (hudWidth - hdWidth) / 2,
                y: hudHeight - hdHeight - 5,
                stroke: '#00ff00',
                'stroke-width': '1px',
                rx: 5,
                ry: 5,
                'fill-opacity': bgOpacity
              });
              /* Draw ticks group. */
              hdTicksArea = heading.group();
              hdTicks = hdTicksArea.group();
              for (i = 0; i < (360 + 90); i++) {
                if (i % 15 == 0) {
                  x = ((hudWidth) / 2) + (pxPerDegree * i);
                  hdTicks.line(x, hudHeight - hdHeight - 3, x, hudHeight - hdHeight + 10).attr({
                    width: 1,
                    stroke: '#00ff00'
                  });

                  var fixedHeading = i;
                  if (i < 0) {
                    fixedHeading = 360 + i;
                  }
                  else if (i >= 360) {
                    fixedHeading = i - 360;
                  }

                  var textHeadingTick = hdTicks.text(fixedHeading.toString()).move(x, hudHeight - hdHeight + 13);
                  textHeadingTick.font({
                    fill: '#00ff00',
                    anchor: 'middle',
                    size: 13
                  });
                }
              }
              for (i = 0; i > (-360 - 90); i--) {
                if (i % 15 == 0) {
                  x = ((hudWidth) / 2) + (pxPerDegree * i);
                  hdTicks.line(x, hudHeight - hdHeight - 3, x, hudHeight - hdHeight + 10).attr({
                    width: 1,
                    stroke: '#00ff00'
                  });

                  var fixedHeading = i;
                  if (i < 0) {
                    fixedHeading = 360 + i;
                  }
                  else if (i >= 360) {
                    fixedHeading = i - 360;
                  }

                  var textHeadingTick = hdTicks.text(fixedHeading.toString()).move(x, hudHeight - hdHeight + 13);
                  textHeadingTick.font({
                    fill: '#00ff00',
                    anchor: 'middle',
                    size: 13
                  });
                }
              }
              /* Draw center heading indicator. */
              var hdCenter = heading.group();
              var hdCenterWidth = 60;
              hdCenter.polyline([
                [hudWidth / 2, hudHeight - hdHeight - 5],
                [(hudWidth + 20) / 2, hudHeight - hdHeight + 10],
                [(hudWidth + hdCenterWidth) / 2, hudHeight - hdHeight + 10],
                [(hudWidth + hdCenterWidth) / 2, hudHeight - 5],
                [(hudWidth - hdCenterWidth) / 2, hudHeight - 5],
                [(hudWidth - hdCenterWidth) / 2, hudHeight - hdHeight + 10],
                [(hudWidth - 20) / 2, hudHeight - hdHeight + 10],
                [hudWidth / 2, hudHeight - hdHeight - 5]]).attr({
                stroke: '#000000',
                'stroke-width': 3,
                'fill-opacity': 0.0
              });
              hdCenter.polyline([
                [hudWidth / 2, hudHeight - hdHeight - 5],
                [(hudWidth + 20) / 2, hudHeight - hdHeight + 10],
                [(hudWidth + hdCenterWidth) / 2, hudHeight - hdHeight + 10],
                [(hudWidth + hdCenterWidth) / 2, hudHeight - 5],
                [(hudWidth - hdCenterWidth) / 2, hudHeight - 5],
                [(hudWidth - hdCenterWidth) / 2, hudHeight - hdHeight + 10],
                [(hudWidth - 20) / 2, hudHeight - hdHeight + 10],
                [hudWidth / 2, hudHeight - hdHeight - 5]]).attr({
                stroke: '#00ff00',
                'stroke-width': 2,
                'fill-opacity': 0.0
              });
              textHeading = draw.text('0').move((hudWidth / 2), hudHeight - hdHeight + 13);
              textHeading.font({
                fill: '#00ff00',
                anchor: 'middle',
                size: 23
              });

              hdTicksMask = heading.mask();

              hdTicksMask.rect(hudWidth, hudHeight).attr({
                fill: '#000000'
              });
              hdTicksMask.rect(hdWidth, hdHeight).attr({
                x: (hudWidth - hdWidth) / 2,
                y: hudHeight - hdHeight - 5,
                stroke: '#00ff00',
                'stroke-width': '1px',
                rx: 5,
                ry: 5,
                fill: '#ffffff'
              });
              hdTicksMask.polyline([
                [hudWidth / 2, hudHeight - hdHeight - 5],
                [(hudWidth + 20) / 2, hudHeight - hdHeight + 10],
                [(hudWidth + hdCenterWidth) / 2, hudHeight - hdHeight + 10],
                [(hudWidth + hdCenterWidth) / 2, hudHeight - 5],
                [(hudWidth - hdCenterWidth) / 2, hudHeight - 5],
                [(hudWidth - hdCenterWidth) / 2, hudHeight - hdHeight + 10],
                [(hudWidth - 20) / 2, hudHeight - hdHeight + 10],
                [hudWidth / 2, hudHeight - hdHeight - 5]]).attr({
                fill: '#000000'
              });
              hdTicksArea.maskWith(hdTicksMask);

              /* -------------------------
               Draw horizon
               ------------------------- */
              hrzWidth = (hudWidth - altWidth) * 0.3;
              var hrzInterval;
              var horizonArea = draw.group();
              pxPerPitchLine = ((hudWidth / 2) / posPitchLineOnScreen);
              pxPerDegreePitch = pxPerPitchLine / degPerPitchLine;
              pitchIndicator = horizonArea.group();

              for (i = 0; i <= 90; i++) {
                if (i % degPerPitchLine == 0) {
                  y = ((hudHeight) / 2) - (pxPerDegreePitch * i);

                  if (i > 0) {
                    pitchIndicator.polyline([
                      [(hudWidth - hrzWidth) / 2, y],
                      [(hudWidth - (hrzWidth * 0.10)) / 2, y],
                      [hudWidth / 2, y + (hrzWidth * 0.05)],
                      [(hudWidth + (hrzWidth * 0.10)) / 2, y],
                      [(hudWidth + hrzWidth) / 2, y]]).attr({
                      'stroke-width': 3,
                      'fill-opacity': 0.0,
                      stroke: '#000000'
                    });
                    pitchIndicator.polyline([
                      [(hudWidth - hrzWidth) / 2, y],
                      [(hudWidth - (hrzWidth * 0.10)) / 2, y],
                      [hudWidth / 2, y + (hrzWidth * 0.05)],
                      [(hudWidth + (hrzWidth * 0.10)) / 2, y],
                      [(hudWidth + hrzWidth) / 2, y]]).attr({
                      'stroke-width': 2,
                      'fill-opacity': 0.0,
                      stroke: '#00ff00'
                    });

                    var fixedPitch = i;
                    if (i > 90) {
                      fixedPitch = 180 - i;
                    }

                    pitchIndicator.rect(20, 20).attr({
                      fill: '#000000',
                      x: (hudWidth - hrzWidth) / 2 - 22,
                      y: y - 10,
                      'fill-opacity': bgOpacity,
                    });
                    var leftTextPitchLine = pitchIndicator.text(fixedPitch.toString()).move((hudWidth - hrzWidth) / 2 - 5, y - 7);
                    leftTextPitchLine.font({
                      fill: '#00ff00',
                      anchor: 'end',
                      size: 15,
                    });

                    pitchIndicator.rect(20, 20).attr({
                      fill: '#000000',
                      x: (hudWidth + hrzWidth) / 2 + 3,
                      y: y - 10,
                      'fill-opacity': bgOpacity,
                    });
                    var rightTextPitchLine = pitchIndicator.text(fixedPitch.toString()).move((hudWidth + hrzWidth) / 2 + 5, y - 7);
                    rightTextPitchLine.font({
                      fill: '#00ff00',
                      anchor: 'start',
                      size: 15,
                    });
                  }
                  else {
                    pitchIndicator.line(-hudWidth, y, 2 * hudWidth, y).attr({
                      'stroke-width': 3,
                      stroke: '#000000'
                    });
                    pitchIndicator.line(-hudWidth, y, 2 * hudWidth, y).attr({
                      'stroke-width': 2,
                      stroke: '#00ff00'
                    });
                  }
                }
              }

              for (i = 0; i >= -90; i--) {
                if (i % degPerPitchLine == 0) {
                  y = ((hudHeight) / 2) - (pxPerDegreePitch * i);

                  if (i < 0) {
                    pitchIndicator.polyline([
                      [(hudWidth - hrzWidth) / 2, y],
                      [(hudWidth - (hrzWidth * 0.10)) / 2, y],
                      [hudWidth / 2, y - (hrzWidth * 0.05)],
                      [(hudWidth + (hrzWidth * 0.10)) / 2, y],
                      [(hudWidth + hrzWidth) / 2, y]]).attr({
                      'stroke-width': 3,
                      'fill-opacity': 0.0,
                      stroke: '#000000'
                    });
                    pitchIndicator.polyline([
                      [(hudWidth - hrzWidth) / 2, y],
                      [(hudWidth - (hrzWidth * 0.10)) / 2, y],
                      [hudWidth / 2, y - (hrzWidth * 0.05)],
                      [(hudWidth + (hrzWidth * 0.10)) / 2, y],
                      [(hudWidth + hrzWidth) / 2, y]]).attr({
                      'stroke-width': 2,
                      'fill-opacity': 0.0,
                      stroke: '#00ff00'
                    });

                    var fixedPitch = i;
                    if (i < -90) {
                      fixedPitch = -180 - i;
                    }

                    pitchIndicator.rect(25, 20).attr({
                      fill: '#000000',
                      x: (hudWidth - hrzWidth) / 2 - 27,
                      y: y - 10,
                      'fill-opacity': bgOpacity,
                    });
                    var leftTextPitchLine = pitchIndicator.text(fixedPitch.toString()).move((hudWidth - hrzWidth) / 2 - 5, y - 7);
                    leftTextPitchLine.font({
                      fill: '#00ff00',
                      anchor: 'end',
                      size: 15,
                    });

                    pitchIndicator.rect(25, 20).attr({
                      fill: '#000000',
                      x: (hudWidth + hrzWidth) / 2 + 3,
                      y: y - 10,
                      'fill-opacity': bgOpacity,
                    });
                    var rightTextPitchLine = pitchIndicator.text(fixedPitch.toString()).move((hudWidth + hrzWidth) / 2 + 5, y - 7);
                    rightTextPitchLine.font({
                      fill: '#00ff00',
                      anchor: 'start',
                      size: 15,
                    });
                  }
                }
              }

              hrzMask = pitchIndicator.mask();
              hrzMask.rect(hudWidth, hudHeight).attr({
                fill: '#000000'
              });
              hrzMask.rect(hudWidth - altWidth - 20, hudHeight - hdHeight - 20).attr({
                fill: '#ffffff',
                x: 5,
                y: 5
              });
              horizonArea.maskWith(hrzMask);
            }
          }

          var pitchDirection = 0.2;
          var altitudeDirection = 0.01;
        }
        if (!($(this).is(':checked'))){
          vid.killVideo();

        }


    });
    window.onhashchange= function(){
      //console.log('gone')
      vid.killVideo();

    };
    window.onbeforeunload= function(){
      //console.log('gone')
      vid.killVideo();
    };
