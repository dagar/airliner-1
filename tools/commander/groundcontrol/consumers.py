"""Consumer.py is the final destination of all websocket routing that happens in django. Each incoming message is picked
up by one of the several workers and gets routed to respective function call in this file. The worker executes the function
passing the message as parameter. The response is written in the received message itself and put back on the channel/socket.
"""
import toolkit as tk
from logger import *
import urllib,json,os,psutil,requests,time,socket,base64,ast
from django.core.cache import cache
from channels import Group
from channels.generic import BaseConsumer
from channels.sessions import channel_session
from websocket import create_connection
from multiprocessing import Process
from pprint import pprint
import inspect
import time,random,redis_lock
from static.proto import web_pb2,pvalue_pb2
import redis,sqlite3
import sys

#NOTE: tk stands for the file toolkit.py has auxillary methods.

# global storage
lc  = tk.launchConfig().get()
mode = lc['_applicationMode']
app_path = lc['_applicationPath']
number_of_workers = lc['_numberOfWorkers']
defaultInstance = lc['_defaultInstance']
address = lc['_localAddress']
port = lc['_yamcsPort']
video_port = lc['_videoPort']
adsb_port =lc['_adsbport']
db_conn = sqlite3.connect(app_path + '/test_database', timeout=5)

def test_db_wrapper(input,output,code,desc):
    """!
    This is a hook to record inputs and subsequent outputs that are generated by Command.
    @param input: a string object before a certain process is applied on it.
    @param output: a string object after the process is applied on it.
    @param code: a user defined string, categorizes various database entries.
    @param desc: description of the process that is applied on the input.
    @return: void
    """
    if mode == 0:
        try:
            tk.collectTestCases(conn, code, input, output, desc)
            conn.commit()
            conn.close()
            logd('Item with code %s has been [INSERT] ed into database.', code)
        except:
            loge('Item with code %s has encountered [ERROR] , inserting into database.', code)
            pass

########################################################
## Fully Bound IO                                     ##
## Bind Tlm to Instance                               ##
########################################################
test_sampling_frequency = (1.0 / 10)
sock_map = {}
proc_map = {}
class session_maintainance(BaseConsumer):

    channel_session = True
    method_mapping = {
        u'websocket.connect': "connect",
        u'websocket.disconnect': "disconnect",
        u'websocket.receive': "recv_handle",
    }

    def connect(self,message):
        message.reply_channel.send({'accept': True})
        logi('Connected to session maintainance.')

    def disconnect(self,message):
        message.reply_channel.send({'close': True})
        logi('Disconnected from session maintainance.')

    def recv_handle(self,message):

        client_reply_channel = message.content['reply_channel']
        obj = tk.byteify(json.loads(message.content['text']))



        if  obj['op'] == 'bind_instance':
            #binding instance name to client
            message.channel_session['instance'] = obj['msg']



        elif obj['op'] == 'subscribe_tlm' :
            tlm_obj = json.loads(obj['msg'])
            tlm_slug = str(tlm_obj['tlm'][0]['name'])
            try:
                my_instance = str(message.channel_session['instance'])
            except:
                logw('Bind the page to instance first.')
            temp = '{"parameter":"subscribe", "data":{"list":' + str(tk.byteify(tlm_obj['tlm'])) + '}}'
            temp = temp.replace("\'", "\"")
            to_send = '[1,1,0,' + str(temp) + ']'
            if client_reply_channel not in sock_map.keys():
                try:
                    ws = create_connection('ws://' + str(address) + ':' + str(port) + '/' + my_instance + '/_websocket')
                    sock_map[client_reply_channel] = ws
                    sock_map[client_reply_channel].send(to_send)
                    process = Process(target=self.push,args=(sock_map[client_reply_channel],my_instance,client_reply_channel,message))
                    process.start()
                    proc_map[client_reply_channel] = process.pid
                    logi('New push process has been created with pid %s.',str(process.pid))
                except Exception, err:
                    loge('Encountered error while creating a process. Error: %s Opt: %s',err,to_send)
                    pass
            else:
                try:
                    sock_map[client_reply_channel].send(to_send)
                    logd('Client %s is now [SUBSCRIBE] to %s bound to instance %s',client_reply_channel,obj['msg'],message.channel_session['instance'])
                except Exception, err:
                    loge('[SUBSCRIBE] error occured for client %s on item %s for instance %s. Error: %s',client_reply_channel,obj['msg'],message.channel_session['instance'],err)
                    pass
            ## Train
            test_db_wrapper(message, 'null', 'SUBTLM', 'subscribe telemetry')


        elif obj['op'] == 'unsubscribe_tlm':
            my_instance = str(message.channel_session['instance'])
            tlm_obj = json.loads(obj['msg'])
            tlm_slug = str(tlm_obj['tlm'][0]['name'])
            try:
                temp = '{"parameter":"unsubscribe", "data":{"list":' + str(tk.byteify(tlm_obj['tlm'])) + '}}'
                temp = temp.replace("\'", "\"")
                to_send = '[1,1,0,' + str(temp) + ']'
                sock_map[client_reply_channel].send(to_send)
                ## Train
                test_db_wrapper(message,'null','KILTLM','unsubscribe telemetry')
                logw('[UNSUBSCRIBE] attempt made for client %s on item %s for instance %s.',client_reply_channel, obj['msg'], message.channel_session['instance'])
            except Exception, err:
                logw('Did not [UNSUBSCRIBE] this time for client %s on item %s for instance %s. Error: %s',client_reply_channel, obj['msg'], message.channel_session['instance'], err)




        elif obj['op'] == 'kill_all_tlm':
            to_kill_pid = proc_map[client_reply_channel]
            try:
                to_kill = psutil.Process(to_kill_pid)
                to_kill.kill()
                del proc_map[client_reply_channel]
                del sock_map[client_reply_channel]
                logw('[TLMKILL] attempt made for client %s on process %s for instance %s.',client_reply_channel, str(to_kill_pid), message.channel_session['instance'])
            except:
                logw('[TLMKILL] attempt made was UNSUCCESSFUL for client %s on process %s for instance %s.',client_reply_channel, str(to_kill_pid), message.channel_session['instance'])
                pass

    def push(self,websocket_obj,inst_name,id,msg_obj):
        """!
        A non-busy forever loop pushes telemetry to client.
        @param websocket_obj:  websocket object
        @return: void
        """
        freq_count = 1
        while True:
            try:
                result = websocket_obj.recv()
                ## If result is not a ACK signal, in YAMCS case ACK looks like `[1,2,x]`
                if result != '[1,2,0]':
                    result2 = tk.preProcess(result,inst_name)
                    msg_obj.reply_channel.send({'text': result2})
                    ##Train
                    ## gets telemetry once every 10 loops
                    if test_sampling_frequency * freq_count == 1:
                        test_db_wrapper(result, result2, 'PREPROCTLM', 'preprocess telemetry before sending')
                        freq_count = 1
                    freq_count += 1
            except Exception, err:
                loge('Push error occured while trying to push messages to client. Error %s',err)
                break
            ## avoids busy-while-loop
            time.sleep(0.01)

########################################################
## Loosely Bound IO                                   ##
## Commanding                                         ##
## Events                                             ##
########################################################
class commanding(BaseConsumer):
    # maps sockets and processess created
    channel_session = True
    method_mapping = {
        u'websocket.connect': "connect",
        u'websocket.disconnect': "disconnect",
        u'websocket.receive': "recv_handle",
    }

    def connect(self, message):
        message.reply_channel.send({'accept': True})
        logi('Connected to commanding.')

    def disconnect(self, message):
        message.reply_channel.send({'close': True})
        logi('Disconnected from commanding.')

    def recv_handle(self, message):

        client_reply_channel = message.content['reply_channel']
        obj = tk.byteify(json.loads(message.content['text']))
        message_text = obj['msg']
        my_instance = obj['inst']




        if obj['op'] == 'RequestCmdDef':
            if message_text == 'HS':
                message.reply_channel.send({'text': 'HSOK'})
                ## got command object
            else:
                response = urllib.urlopen('http://' + str(address) + ':' + str(port) + '/api/mdb/' + str(my_instance) + '/commands' + message_text)
                data = json.loads(json.dumps(response.read()))
                data = data.replace("\"", "\'")
                message.reply_channel.send({'text': data})
                ## Train
                test_db_wrapper(message_text, data, 'CMDINFO', 'commanding information')




        elif obj['op'] == 'sendCommand':
            to_post = json.loads(message_text)
            url = 'http://' + str(address) + ':' + str(port) + '/api/processors/' + str(my_instance) + '/realtime/commands' + to_post['name'] + '?nolink'
            msg = '{"sequenceNumber": 0,"origin": "user@my-machine","assignment":' + str(json.dumps(to_post['args'])) + ',"dryRun": false}'
            headers = {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }
            r = requests.post(url=url, data=msg, headers=headers)
            got = r.text
            op = json.dumps({"cmd": got, "code": r.status_code})
            message.reply_channel.send({'text': op})
            ## Train
            test_db_wrapper(message_text, r.status_code, 'CMDPOST', 'sending commands')

# event variables
sock_map_e = {}
proc_map_e = {}
class events(BaseConsumer):
    #channel_session = True
    method_mapping = {
        u'websocket.connect': "connect",
        u'websocket.disconnect': "disconnect",
        u'websocket.receive': "recv_handle",
    }
    def connect(self,message):
        """!
        Accepts request and establishes a connection with client.
        @param message: connection request from client, this message will connection headers.
        @return: void
        """
        message.reply_channel.send({'accept': True})

    def disconnect(self,message):
        """!
        Accepts disconnection message and disconnects with client.
        @param message: disconnection request from client, this message will disconnection headers.
        @return: void
        """
        message.reply_channel.send({'close': True})

    def recv_handle(self,message):
        """!
        Upon receipt of invoke signal this function generates a process which pushes live event feeds to client.
        Upon receipt of kill signal the fucntion will kill the running process.
        @param message: event message object is sent from the client.
        @return: void
        """
        message_text = message.content['text']
        client_id = message.content['reply_channel']
        ## when invoke signal is received
        if message_text == 'INVOKE':
            data = '[1, 1, 1, {"events": "subscribe"}]'
            ws = None
            if defaultInstance == 'None':
                ws = create_connection('ws://' + address + ':' + str(port) + '/'+redis_cache.get('default_instance')+'/_websocket')
            else:
                ws = create_connection('ws://' + address + ':' + str(port) + '/'+defaultInstance+'/_websocket')
            ws.send(data)
            t = Process(target=self.push, args=(ws, message))
            t.start()
            proc_map_e[client_id] = t.pid
            sock_map_e[client_id] = ws
        # when kill signal is received
        elif message_text =='KILLSWITCH':
            try:
                us_sock = sock_map_e[client_id]
                data = '[1, 1, 1, {"events": "unsubscribe"}]'
                us_sock.send(data)
                logd('Events are [UNSIBSCRIBED] for client %s .',client_id)
            except:
                ## TODO: safely log error, unit test required
                logw('Unable to [UNSUBSCTIBE] events.')
                pass
            try:
                to_kill_pid = proc_map_e[client_id]
                to_kill = psutil.Process(to_kill_pid)
                to_kill.kill()
                logd('Event [KILLED] has pid: %s .' , to_kill_pid)
            except:
                ## TODO: safely log error, unit test required
                logw('Unable to [KILL] event.')
                pass

    def push(self,websocket_obj,message_obj):
        """!
        A non-busy forever loop pushes events to client.
        @param websocket_obj:  websocket object
        @param message_obj:  message object
        @return: void
        """
        while True:
            result = websocket_obj.recv()
            ## If result is not a ACK signal, in YAMCS case ACK for events looks like `[1,4,x]`
            if result.find('[1,4,')!=-1 :
                message_obj.reply_channel.send({'text': result})
                logd('Event Received.')
            ## avoids busy-while-loop
            time.sleep(0.01)
            ## Train

########################################################
## Independent IO                                     ##
## Instance                                           ##
## Directory                                          ##
## Video                                              ##
## ADS-B                                              ##
########################################################
# instance list
def inst_connect(message):
    """!
    Accepts request and establishes a connection with client.
    @param message: connection request from client, this message will connection headers.
    @return: void
    """
    message.reply_channel.send({'accept': True})

def inst_disconnect(message):
    """!
    Accepts disconnection message and disconnects with client.
    @param message: disconnection request from client, this message will disconnection headers.
    @return: void
    """
    message.reply_channel.send({'close': True})

def getInstanceList(message):
    """!
    This function is invoked by the client. Upon such an event, an instance list is requested from
    pyliner/yamcs which is forwarded to client.
    @param message: invoke signal sent from client
    @return: void
    """
    name = message.content['text']
    response = urllib.urlopen('http://' + str(address) + ':' + str(port) + '/api/instances')
    data = json.loads(json.dumps(response.read()))
    message.reply_channel.send({'text': data})
    logi('Instances list is sent.')

# directory list
def dir_connect(message):
    """!
    Accepts request and establishes a connection with client.
    @param message: connection request from client, this message will connection headers.
    @return: void
    """
    message.reply_channel.send({'accept': True})

def dir_disconnect(message):
    """!
    Accepts disconnection message and disconnects with client.
    @param message: disconnection request from client, this message will disconnection headers.
    @return: void
    """
    message.reply_channel.send({'close': True})

def directoryListing(message):
    """!
    Takes the file or directory name in the  message object, scrapes file system and sends out a json to client
    which has sub-directories listed.
    @param message: message object with directory or file name is sent from the client.
    @return: void
    """
    name = message.content['text']
    response = tk.get_directory(name)
    data = json.dumps(response)
    ## Train
    test_db_wrapper(name, data,'DIR','obtain directory listing')
    message.reply_channel.send({'text': data})
    logi('Directory list under \' %s \' is sent.',name)

# ads-b link
adsb_proc = []

def adsb_connect(message):
    """!
        Accepts request and establishes a connection with client.
        @param message: connection request from client, this message will connection headers.
        @return: void
        """
    message.reply_channel.send({'accept': True})

def adsb_disconnect(message):
    """!
       Accepts disconnection message and disconnects with client.
       @param message: disconnection request from client, this message will disconnection headers.
       @return: void
       """
    message.reply_channel.send({'close': True})

def getAdsb(message):

    text = message.content['text']
    client_reply_channel = message.content['reply_channel']
    if text == 'INVOKE':
        if len(Group('adsb10').channel_layer.group_channels('adsb10'))!=0:
            Group('adsb10').add(message.reply_channel)
        else:
            process = Process(target=adsbPush, args=(message,))
            process.start()
            Group('adsb10').add(message.reply_channel)
            adsb_proc.append(process.pid)
            logw('Donot Terminate adsb with ctrl+c, terminate from client.')
            logi('New adsb-push process has been [Created] with pid %s.', str(process.pid))
    elif text == 'KILL':
        if len(Group('adsb10').channel_layer.group_channels('adsb10')) > 1 :
            Group('adsb10').discard(message.reply_channel)
        elif client_reply_channel in Group('adsb10').channel_layer.group_channels('adsb10'):
            Group('adsb10').send({'text': 'KILLED'})
            for each in adsb_proc:
                to_kill = psutil.Process(each)
                to_kill.kill()
                adsb_proc.remove(each)
                Group('adsb10').discard(message.reply_channel)
                logi('Adsb-push process has been [Killed] with pid %s.', str(each))

def adsbPush(message):
    """!
    A non-busy forever loop pushes telemetry to client.
    @param websocket_obj:  websocket object
    @return: void
    """
    while True:
        try:
            response = urllib.urlopen('http://' + str(address) + ':' + str(adsb_port) + '/dump1090/data.json')
            data = json.loads(json.dumps(response.read()))
            Group('adsb10').send({'text': data})
            #message.reply_channel.send({'text': data})
            logi('ads-b packet is sent.')

        except Exception, err:
            Group('adsb10').discard(message.reply_channel)
            loge('Adsb-push error occured while trying to push messages to client. Error %s', err)
            break
        ## avoids busy-while-loop
        time.sleep(1)

#  video link
vid_proc = []
def vid_connect( message):
    """!
    Accepts request and establishes a connection with client.
    @param message: connection request from client, this message will connection headers.
    @return: void
    """
    message.reply_channel.send({'accept': True})

def vid_disconnect( message):
    """!
    Accepts disconnection message and disconnects with client.
    @param message: disconnection request from client, this message will disconnection headers.
    @return: void
    """
    message.reply_channel.send({'close': True})

def getVideo(message):
    """!
    Invokes a continuous looping function which will push video images to client.
    @param message: invoke message from client.
    @return: void
    """
    text = message.content['text']
    client_reply_channel = message.content['reply_channel']
    if text == 'INVOKE':
        if len(Group('vid7').channel_layer.group_channels('vid7'))!=0:
            Group('vid7').add(message.reply_channel)
        else:
            process = Process(target=VideoThroughUDP, args=(message,))
            process.start()
            Group('vid7').add(message.reply_channel)
            vid_proc.append(process.pid)
            logw('Donot Terminate vid with ctrl+c, terminate from client.')
            logi('New video-push process has been [Created] with pid %s.', str(process.pid))
    elif text == 'KILL':
        if len(Group('vid7').channel_layer.group_channels('vid7')) > 1 :
            Group('vid7').discard(message.reply_channel)
        elif client_reply_channel in Group('vid7').channel_layer.group_channels('vid7'):
            Group('vid7').send({'text': 'KILLED'})
            for each in vid_proc:
                to_kill = psutil.Process(each)
                to_kill.kill()
                vid_proc.remove(each)
                Group('vid7').discard(message.reply_channel)
                logi('video-push process has been [Killed] with pid %s.', str(each))

def VideoThroughUDP(msg_obj):
    """!
    Binds with UDP port and forwards image data as and when received from pyliner/yamcs.
    @param msg_obj: ivoke message passed as parameter in `getVideo' function.
    @return: void
    """
    ## UDP
    video_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    video_socket.bind(('', video_port))
    video_frame_counter = 0

    while True:
        try:
            ## buffer size is 65527 bytes
            data, addr = video_socket.recvfrom(65527)
            b64_img = base64.b64encode(data)
            video_frame_counter = video_frame_counter + 1
            Group('vid7').send({'text': b64_img})
            #msg_obj.reply_channel.send({'text': b64_img})
            #logi('video frame #%s is sent.', video_frame_counter)
            #video_frame_counter = video_frame_counter + 1
            # yield b64_img


        except Exception, err:
            Group('vid7').discard(message.reply_channel)
            loge('Video-push error occured while trying to push messages to client. Error %s', err)
            break
        ## avoids busy-while-loop
        time.sleep(0.01)








